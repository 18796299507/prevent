diff --git a/services/core/java/com/android/server/IntentResolver.java b/services/core/java/com/android/server/IntentResolver.java
index 3359060..464df55 100644
--- a/services/core/java/com/android/server/IntentResolver.java
+++ b/services/core/java/com/android/server/IntentResolver.java
@@ -692,7 +692,7 @@ public abstract class IntentResolver<F extends IntentFilter, R extends Object> {
         final Uri data = intent.getData();
         final String packageName = intent.getPackage();
 
-        final boolean excludingStopped = intent.isExcludingStopped();
+        final boolean excludingStopped = com.android.server.am.PreventRunningUtils.isExcludingStopped(intent);
 
         final Printer logPrinter;
         final PrintWriter logPrintWriter;
@@ -746,7 +746,7 @@ public abstract class IntentResolver<F extends IntentFilter, R extends Object> {
                 continue;
             }
 
-            match = filter.match(action, resolvedType, scheme, data, categories, TAG);
+            match = com.android.server.am.PreventRunningUtils.match(filter, action, resolvedType, scheme, data, categories, TAG);
             if (match >= 0) {
                 if (debug) Slog.v(TAG, "  Filter matched!  match=0x" +
                         Integer.toHexString(match) + " hasDefault="
diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index 58f7f10..5a8067a 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -2287,6 +2287,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     // Note: This method is invoked on the main thread but may need to attach various
     // handlers to other threads.  So take care to be explicit about the looper.
     public ActivityManagerService(Context systemContext) {
+        PreventRunningUtils.init(this);
         mContext = systemContext;
         mFactoryTest = FactoryTest.getMode();
         mSystemThread = ActivityThread.currentActivityThread();
@@ -3067,6 +3068,9 @@ public final class ActivityManagerService extends ActivityManagerNative
             ApplicationInfo info, boolean knownToBeDead, int intentFlags,
             String hostingType, ComponentName hostingName, boolean allowWhileBooting,
             boolean isolated, boolean keepIfLarge) {
+        if (!PreventRunningUtils.hookStartProcessLocked(info, knownToBeDead, intentFlags, hostingType, hostingName)) {
+            return null;
+        }
         return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,
                 hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge,
                 null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */,
@@ -3799,9 +3803,10 @@ public final class ActivityManagerService extends ActivityManagerNative
     public final int startActivity(IApplicationThread caller, String callingPackage,
             Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
             int startFlags, ProfilerInfo profilerInfo, Bundle options) {
-        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
+        return PreventRunningUtils.onStartActivity(
+                startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
             resultWho, requestCode, startFlags, profilerInfo, options,
-            UserHandle.getCallingUserId());
+            UserHandle.getCallingUserId()), caller, intent);
     }
 
     @Override
@@ -4668,6 +4673,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                 Slog.i(TAG, "Process " + app.processName + " (pid " + pid
                         + ") has died");
                 mAllowLowerMemLevel = true;
+                PreventRunningUtils.onAppDied(app);
             } else {
                 // Note that we always want to do oom adj to update our state with the
                 // new number of procs.
@@ -5297,7 +5303,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                 if (proc.pkgDeps == null) {
                     proc.pkgDeps = new ArraySet<String>(1);
                 }
-                proc.pkgDeps.add(packageName);
+                proc.pkgDeps.size();
             }
         }
     }
@@ -8678,6 +8684,8 @@ public final class ActivityManagerService extends ActivityManagerNative
                 pr.waitingToKill = "remove task";
             }
         }
+
+        PreventRunningUtils.onCleanUpRemovedTask(pkg);
     }
 
     private void removeTasksByPackageNameLocked(String packageName, int userId) {
@@ -8811,7 +8819,8 @@ public final class ActivityManagerService extends ActivityManagerNative
                         mStackSupervisor.showLockTaskToast();
                         return false;
                     }
-                    return ActivityRecord.getStackLocked(token).moveTaskToBackLocked(taskId);
+                    return PreventRunningUtils.onMoveActivityTaskToBack(
+                            ActivityRecord.getStackLocked(token).moveTaskToBackLocked(taskId), token);
                 }
             } finally {
                 Binder.restoreCallingIdentity(origId);
@@ -15674,12 +15683,14 @@ public final class ActivityManagerService extends ActivityManagerNative
         if (DEBUG_SERVICE) Slog.v(TAG_SERVICE,
                 "startService: " + service + " type=" + resolvedType);
         synchronized(this) {
+            PreventRunningUtils.setSender(caller);
             final int callingPid = Binder.getCallingPid();
             final int callingUid = Binder.getCallingUid();
             final long origId = Binder.clearCallingIdentity();
             ComponentName res = mServices.startServiceLocked(caller, service,
                     resolvedType, callingPid, callingUid, callingPackage, userId);
             Binder.restoreCallingIdentity(origId);
+            PreventRunningUtils.setSender();
             return res;
         }
     }
@@ -15909,8 +15920,9 @@ public final class ActivityManagerService extends ActivityManagerNative
         }
 
         synchronized(this) {
-            return mServices.bindServiceLocked(caller, token, service,
-                    resolvedType, connection, flags, callingPackage, userId);
+            PreventRunningUtils.setSender(caller);
+            return PreventRunningUtils.setSender(mServices.bindServiceLocked(caller, token, service,
+                    resolvedType, connection, flags, callingPackage, userId));
         }
     }
 
@@ -16935,12 +16947,14 @@ public final class ActivityManagerService extends ActivityManagerNative
             final int callingPid = Binder.getCallingPid();
             final int callingUid = Binder.getCallingUid();
             final long origId = Binder.clearCallingIdentity();
-            int res = broadcastIntentLocked(callerApp,
+            PreventRunningUtils.setSender(callerApp);
+            int res = PreventRunningUtils.onBroadcastIntent(broadcastIntentLocked(callerApp,
                     callerApp != null ? callerApp.info.packageName : null,
                     intent, resolvedType, resultTo, resultCode, resultData, resultExtras,
                     requiredPermissions, appOp, null, serialized, sticky,
-                    callingPid, callingUid, userId);
+                    callingPid, callingUid, userId), intent);
             Binder.restoreCallingIdentity(origId);
+            PreventRunningUtils.setSender();
             return res;
         }
     }
diff --git a/services/core/java/com/android/server/am/ActivityStack.java b/services/core/java/com/android/server/am/ActivityStack.java
index 6e34876..17a9a8b 100644
--- a/services/core/java/com/android/server/am/ActivityStack.java
+++ b/services/core/java/com/android/server/am/ActivityStack.java
@@ -866,6 +866,7 @@ final class ActivityStack {
                 mService.updateUsageStats(prev, false);
                 prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,
                         userLeaving, prev.configChangeFlags, dontWait);
+                PreventRunningUtils.onUserLeavingActivity(prev, userLeaving);
             } catch (Exception e) {
                 // Ignore exception, if process died other code will cleanup.
                 Slog.w(TAG, "Exception thrown during pause", e);
@@ -1943,6 +1944,7 @@ final class ActivityStack {
                 next.clearOptionsLocked();
                 next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,
                         mService.isNextTransitionForward(), resumeAnimOptions);
+                PreventRunningUtils.onResumeActivity(next);
 
                 mStackSupervisor.checkReadyForSleepLocked();
 
@@ -3377,6 +3379,7 @@ final class ActivityStack {
                 if (DEBUG_SWITCH) Slog.i(TAG_SWITCH, "Destroying: " + r);
                 r.app.thread.scheduleDestroyActivity(r.appToken, r.finishing,
                         r.configChangeFlags);
+                PreventRunningUtils.onDestroyActivity(r);
             } catch (Exception e) {
                 // We can just ignore exceptions here...  if the process
                 // has crashed, our death notification will clean things
diff --git a/services/core/java/com/android/server/am/ActivityStackSupervisor.java b/services/core/java/com/android/server/am/ActivityStackSupervisor.java
index 6d91309..b4ab916 100644
--- a/services/core/java/com/android/server/am/ActivityStackSupervisor.java
+++ b/services/core/java/com/android/server/am/ActivityStackSupervisor.java
@@ -1286,6 +1286,7 @@ public final class ActivityStackSupervisor implements DisplayListener {
                     new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,
                     task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,
                     newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);
+            PreventRunningUtils.onLaunchActivity(r);
 
             if ((app.info.privateFlags&ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) {
                 // This may be a heavy-weight process!  Note that the package
diff --git a/services/core/java/com/android/server/am/PreventRunningUtils.java b/services/core/java/com/android/server/am/PreventRunningUtils.java
new file mode 100644
index 0000000..1452262
--- /dev/null
+++ b/services/core/java/com/android/server/am/PreventRunningUtils.java
@@ -0,0 +1,113 @@
+package com.android.server.am;
+
+import android.app.IApplicationThread;
+import android.content.ComponentName;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.ApplicationInfo;
+import android.net.Uri;
+import android.os.IBinder;
+
+import java.util.Set;
+
+import me.piebridge.PreventRunning;
+
+public class PreventRunningUtils {
+
+    private static ActivityManagerService mAm;
+
+    private static PreventRunning mPreventRunning = new PreventRunning();
+
+    private PreventRunningUtils() {
+    }
+
+    public static void init(ActivityManagerService am) {
+        mAm = am;
+    }
+
+    public static void onUserLeavingActivity(ActivityRecord ar, boolean userLeaving) {
+        if (userLeaving) {
+            mPreventRunning.onUserLeavingActivity(ar);
+        }
+    }
+
+    public static void onResumeActivity(ActivityRecord ar) {
+        mPreventRunning.onResumeActivity(ar);
+    }
+
+    public static void onDestroyActivity(ActivityRecord ar) {
+        mPreventRunning.onDestroyActivity(ar);
+    }
+
+    public static void onLaunchActivity(ActivityRecord ar) {
+        mPreventRunning.onLaunchActivity(ar);
+    }
+
+    public static void setSender() {
+        mPreventRunning.setSender(null);
+    }
+
+    public static void setSender(IApplicationThread caller) {
+        final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);
+        mPreventRunning.setSender(callerApp != null ? callerApp.info.packageName : null);
+    }
+
+    public static void setSender(ProcessRecord callerApp) {
+        mPreventRunning.setSender(callerApp != null ? callerApp.info.packageName : null);
+    }
+
+    public static int setSender(int res) {
+        mPreventRunning.setSender(null);
+        return res;
+    }
+
+    public static void onAppDied(ProcessRecord app) {
+        mPreventRunning.onAppDied(app);
+    }
+
+    public static void onCleanUpRemovedTask(String packageName) {
+        mPreventRunning.onCleanUpRemovedTask(packageName);
+    }
+
+    public static boolean onMoveActivityTaskToBack(boolean res, IBinder token) {
+        if (res) {
+            mPreventRunning.onMoveActivityTaskToBack(ActivityRecord.forTokenLocked(token).packageName);
+        }
+        return res;
+    }
+
+    public static int onBroadcastIntent(int res, Intent intent) {
+        if (res >= 0) {
+            mPreventRunning.onBroadcastIntent(intent);
+        }
+        return res;
+    }
+
+    public static boolean isExcludingStopped(Intent intent) {
+        String action = intent.getAction();
+        return intent.isExcludingStopped() && action != null && mPreventRunning.isExcludingStopped(action);
+    }
+
+    public static int match(IntentFilter filter, String action, String type, String scheme, Uri data, Set<String> categories, String tag) {
+        int match = filter.match(action, type, scheme, data, categories, tag);
+        if (match >= 0) {
+            return mPreventRunning.match(match, filter, action, type, scheme, data, categories);
+        } else {
+            return match;
+        }
+    }
+
+    public static int onStartActivity(int res, IApplicationThread caller, Intent intent) {
+        if (res >= 0 && intent != null && intent.hasCategory(Intent.CATEGORY_HOME)) {
+            ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);
+            if (callerApp != null) {
+                mPreventRunning.onStartHomeActivity(callerApp.info.packageName);
+            }
+        }
+        return res;
+    }
+
+    public static boolean hookStartProcessLocked(ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName) {
+        return mPreventRunning.hookStartProcessLocked(mAm.mContext, info, hostingType, hostingName);
+    }
+}
diff --git a/services/core/java/me/piebridge/PreventRunning.java b/services/core/java/me/piebridge/PreventRunning.java
new file mode 100644
index 0000000..b396965
--- /dev/null
+++ b/services/core/java/me/piebridge/PreventRunning.java
@@ -0,0 +1,151 @@
+package me.piebridge;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ApplicationInfo;
+import android.net.Uri;
+import android.util.Log;
+
+import java.io.File;
+import java.lang.Throwable;
+import java.util.Set;
+
+import dalvik.system.DexClassLoader;
+
+/**
+ * Created by thom on 15/10/27.
+ */
+public class PreventRunning implements PreventRunningHook {
+
+    private static final String TAG = "Prevent";
+
+    private PreventRunningHook mPreventRunning;
+
+    private static File[] APKS = {
+            new File("/data/app/me.piebridge.forcestopgb-1/base.apk"),
+            new File("/data/app/me.piebridge.forcestopgb-2/base.apk"),
+            new File("/data/app/me.piebridge.forcestopgb-3/base.apk"),
+            new File("/data/app/me.piebridge.forcestopgb-1.apk"),
+            new File("/data/app/me.piebridge.forcestopgb-2.apk"),
+            new File("/data/app/me.piebridge.forcestopgb-3.apk"),
+    };
+
+    public PreventRunning() {
+        for (File apk : APKS) {
+            if (apk.exists() && initPreventRunning(apk)) {
+                break;
+            }
+        }
+    }
+
+    private boolean initPreventRunning(File apk) {
+        try {
+            ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();
+            ClassLoader classLoader = new DexClassLoader(apk.getAbsolutePath(), "/cache", null, currentClassLoader);
+            Log.d(TAG, "loading PreventRunning from " + apk);
+            mPreventRunning = (PreventRunningHook) classLoader.loadClass("me.piebridge.prevent.framework.PreventRunning").newInstance();
+            return true;
+        } catch (ClassNotFoundException e) {
+            Log.d(TAG, "cannot find class", e);
+        } catch (InstantiationException e) {
+            Log.d(TAG, "cannot instance class", e);
+        } catch (IllegalAccessException e) {
+            Log.d(TAG, "cannot access class", e);
+        } catch (Throwable t) { // NOSONAR
+            Log.d(TAG, "cannot load PreventRunning from " + apk, t);
+        }
+        return false;
+    }
+
+    @Override
+    public void setSender(String sender) {
+        if (mPreventRunning != null) {
+            mPreventRunning.setSender(sender);
+        }
+    }
+
+    @Override
+    public void onBroadcastIntent(Intent intent) {
+        if (mPreventRunning != null) {
+            mPreventRunning.onBroadcastIntent(intent);
+        }
+    }
+
+    @Override
+    public void onCleanUpRemovedTask(String packageName) {
+        if (mPreventRunning != null) {
+            mPreventRunning.onCleanUpRemovedTask(packageName);
+        }
+    }
+
+    @Override
+    public void onStartHomeActivity(String packageName) {
+        if (mPreventRunning != null) {
+            mPreventRunning.onStartHomeActivity(packageName);
+        }
+    }
+
+    @Override
+    public void onMoveActivityTaskToBack(String packageName) {
+        if (mPreventRunning != null) {
+            mPreventRunning.onMoveActivityTaskToBack(packageName);
+        }
+    }
+
+    @Override
+    public void onAppDied(Object processRecord) {
+        if (mPreventRunning != null) {
+            mPreventRunning.onAppDied(processRecord);
+        }
+    }
+
+    @Override
+    public void onLaunchActivity(Object activityRecord) {
+        if (mPreventRunning != null) {
+            mPreventRunning.onLaunchActivity(activityRecord);
+        }
+    }
+
+    @Override
+    public void onResumeActivity(Object activityRecord) {
+        if (mPreventRunning != null) {
+            mPreventRunning.onResumeActivity(activityRecord);
+        }
+    }
+
+    @Override
+    public void onUserLeavingActivity(Object activityRecord) {
+        if (mPreventRunning != null) {
+            mPreventRunning.onUserLeavingActivity(activityRecord);
+        }
+    }
+
+    @Override
+    public void onDestroyActivity(Object activityRecord) {
+        if (mPreventRunning != null) {
+            mPreventRunning.onDestroyActivity(activityRecord);
+        }
+    }
+
+    @Override
+    public boolean isExcludingStopped(String action) {
+        return mPreventRunning == null || mPreventRunning.isExcludingStopped(action);
+    }
+
+
+    @Override
+    public boolean hookStartProcessLocked(Context context, ApplicationInfo info, String hostingType, ComponentName hostingName) {
+        return mPreventRunning == null || mPreventRunning.hookStartProcessLocked(context, info, hostingType, hostingName);
+    }
+
+    @Override
+    public int match(int match, Object filter, String action, String type, String scheme, Uri data, Set<String> categories) {
+        if (mPreventRunning != null) {
+            return mPreventRunning.match(match, filter, action, type, scheme, data, categories);
+        } else {
+            return match;
+        }
+    }
+
+}
diff --git a/services/core/java/me/piebridge/PreventRunningHook.java b/services/core/java/me/piebridge/PreventRunningHook.java
new file mode 100644
index 0000000..98ea8c0
--- /dev/null
+++ b/services/core/java/me/piebridge/PreventRunningHook.java
@@ -0,0 +1,42 @@
+package me.piebridge;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ApplicationInfo;
+import android.net.Uri;
+
+import java.util.Set;
+
+/**
+ * Created by thom on 15/10/27.
+ */
+public interface PreventRunningHook {
+
+    void setSender(String sender);
+
+    void onBroadcastIntent(Intent intent);
+
+    void onCleanUpRemovedTask(String packageName);
+
+    void onStartHomeActivity(String sender);
+
+    void onMoveActivityTaskToBack(String packageName);
+
+    void onAppDied(Object processRecord);
+
+    void onLaunchActivity(Object activityRecord);
+
+    void onResumeActivity(Object activityRecord);
+
+    void onUserLeavingActivity(Object activityRecord);
+
+    void onDestroyActivity(Object activityRecord);
+
+    boolean isExcludingStopped(String action);
+
+    boolean hookStartProcessLocked(Context context, ApplicationInfo info, String hostingType, ComponentName hostingName);
+
+    int match(int match, Object filter, String action, String type, String scheme, Uri data, Set<String> categories);
+
+}
